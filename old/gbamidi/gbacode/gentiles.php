#!/usr/bin/php
<?

/*
Firmware for a gba-to-midi-cable with integrated sequencer/synthesizer
(C) 2011 Jeroen Domburg (jeroen AT spritesmods.com)

This program is free software: you can redistribute it and/or modify
t under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
	    
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
			    
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/



/*
This li'l tool converts tiles.png into something RLE-compressed that can be
understood by the gfxloader.c routines.

Format: The array that's spat out can be understood as a stream of nibbles,
which are packed high-to-low into bytes. The stream consists of two types of blocks.
The first one starts with a nibble with value N between 0-8. This indicates the
next N nibbles should be copied verbatim to video memory. The other type
of block starts with a nibble with value N between 9 and 15. This means the
next nibble should be written (n-8) times to memory.
*/

$start=31;
$end=142;

$tileDataRle=array();

function addNibble($n) {  //Handles the RLE encoding.
	global $tileDataRle;
	static $repeating=0;
	static $data=array();

	if (count($data)==0) {
		$data=array($n);
	} else if (count($data)==1) {
		if ($data[0]==$n) {
			$repeating=1;
		} else {
			$repeating=0;
		}
		$data[]=$n;
	} else {
		//Len>=2
		if ($repeating) {
			if (count($data)==8 || $n!=$data[0]) {
				$tileDataRle[]=count($data);
				$tileDataRle[]=$data[0];
				$data=array($n);
			} else {
				$data[]=$n;
			}
		} else {
			if (count($data)==7 || $n==$data[count($data)-1]) {
				$tileDataRle[]=count($data)+8;
				for ($x=0; $x<count($data); $x++) $tileDataRle[]=$data[$x];
				$data=array($n);
			} else {
				$data[]=$n;
			}
		}
	}
//	echo "data=$n Len=".count($data)." repeating=$repeating\n";
//	var_dump($data);
//	var_dump($tileDataRle);
}


function genTileStr($i, $xoff, $yoff) {  //Tile image -> binary data conversion
	for ($y=0; $y<8; $y++) {
		for ($x=0; $x<8; $x+=2) {
			addNibble(imagecolorat($i, $x+$xoff+1, $y+$yoff));
			addNibble(imagecolorat($i, $x+$xoff, $y+$yoff));
		}
	}
}

function getPalRgb($i, $x) {
	if ($x>=imagecolorstotal($i)) return -1;
	$n=imagecolorsforindex($i, $x);
	$r=($n["red"]>>3);
	$r+=($n["green"]>>3)<<5;
	$r+=($n["blue"]>>3)<<10;
	return $r;
}

$i=imagecreatefrompng("tiles.png");

echo "//Autogenerated from tiles.png using gentiles.php\n";
echo "#include \"tiles.h\"\n";
echo "\n";
echo "const unsigned short paletteData[]={\n    ";
//Convert palette to GBA format
for ($x=0; $x<16; $x++) {
	printf("0x%04x", getPalRgb($i, $x));
	if (getPalRgb($i, $x+1)!=-1) echo ", "; else break;
}
echo "\n    };\n\n";


//Convert tiles to GBA format
$n=0;
$tileDataRle=array();
for ($y=1; $y<9*16; $y+=9) {
	for ($x=1; $x<9*16; $x+=9) {
		if ($n>=$start && $n<$end) genTileStr($i, $x, $y)."\n";
		$n++;
	}
}

//Write tile data
echo "const unsigned char tileData[]={";
for ($x=0; $x<sizeof($tileDataRle); $x+=2) {

	$b=$tileDataRle[$x]*16;
	$b=$b|($tileDataRle[($x+1)]);

	if (($x&31)==0) echo "\n    ";
	printf("0x%02x, ", $b);
}
echo "    0};\n"


?>